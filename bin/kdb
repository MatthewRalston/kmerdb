#!/usr/bin/env python

import logging
import argparse
import os
import sys
import yaml
from multiprocessing import cpu_count
from collections import OrderedDict


from Bio import bgzf

#import concurrent.futures

logger=None


def index_file(arguments):
    from kdb import fileutil, index
    with fileutil.open(arguments.kdb, mode='r') as kdb:
        header = kdb.header
    line_index = index.build_line_index_from_kdb(arguments.kdb, header['k'])
    index._write_line_index(arguments.kdbi, line_index)

def distances(arguments):
    if len(arguments.kdb) < 2:
        logger.error("kdb distance requires at least two .kdb files.")
        sys.exit(1)

    from kdb import distance
    n = len(arguments.kdb)
    data = [['' for x in range(n)] for y in range(n)]

    for i in range(n):
        for j in range(n):
            if i == j:
                data[i][j] = distance.identity[arguments.metric]
            elif i > j:
                data[i][j] = ''
            else:
                data[i][j] = distance.correlation(arguments.kdb[i], arguments.kdb[j])
    #print(data)
    logger.info("Printing distance matrix...")
    if len(arguments.kdb) == 2:
        print(data[0][1])
    else:
        for x in range(len(arguments.kdb)):
            print("\t".join(map(str, data[x])))

def header(arguments):
    from kdb import fileutil
    from config import VERSION

    with fileutil.open(arguments.kdb, mode='r') as kdb:
        if kdb.header["version"] != VERSION:
            logger.warning("KDB version is out of date, may be incompatible with current KDBReader class")
        if arguments.json:
            print(kdb.header)
        else:
            print(yaml.dump(kdb.header))
    
            
def view(arguments):
    from kdb import fileutil

    from config import VERSION

    with fileutil.open(arguments.kdb, mode='r') as kdb:
        if kdb.header["version"] != VERSION:
            logger.warning("KDB version is out of date, may be incompatible with current KDBReader class")
        if arguments.header:
            print(yaml.dump(kdb.header))
        for line in kdb:
            print(line.rstrip())

def profile(arguments):
    import math
    from kdb import parse, fileutil

    from config import VERSION

    metadata = []
    tempdbs = []
    for f in arguments.seqfile:
        db, m = parse.parsefile(f, arguments.k, p=arguments.parallel, b=arguments.fastq_block_size, stranded=arguments.not_strand_specific)
        metadata.append(m)
        tempdbs.append(db)
    header=OrderedDict({
        "version": VERSION,
        "metadata_blocks": 1,
        "k": arguments.k,
        "metadata": False,
        "tags": [],
        "files": metadata
    })
    
    header_bytes = bgzf._as_bytes(yaml.dump(header))
    # The number of metadata blocks is the number of bytes of the header block(s) / the number of bytes per block in the BGZF specification
    header["metadata_blocks"] = math.ceil( sys.getsizeof(header_bytes) / ( 2**16 ) ) # First estimate
    header_bytes = bgzf._as_bytes(yaml.dump(header))
    header["metadata_blocks"] = math.ceil( sys.getsizeof(header_bytes) / ( 2**16 ) ) # Second estimate
    #header["metadata_blocks"] = 2
    logger.info("Collapsing the k-mer counts across the various input files into the final kdb file '{0}'".format(arguments.kdb))    
    try:
        kdb_out = fileutil.KDBWriter(header, fileobj=open(arguments.kdb, 'wb'))
        iterating = True
        while iterating:
            # The 0th element is the count
            try:

                kmer_counts_per_file = list(map(next, tempdbs)) # T
                if len(kmer_counts_per_file):
                    i = kmer_counts_per_file[0][0] - 1 # Remove 1 for the Sqlite zero-based indexing
                    count = sum([x[1] for x in kmer_counts_per_file]) # The 1th element is the k-mer count
                    #sys.stderr.write("\r")
                    sys.stderr.write("K-mer counts: {0} = {1}\n".format(list(map(lambda x: x[1], kmer_counts_per_file)), count))
                    kdb_out.write("{0}\t{1}\n".format(i, count))
                else:
                    iterating = False
            except StopIteration as e:
                logger.warn("Shouldn't have encountered StopIteration error...")
                logger.warn("Continuing anyways...")
                iterating = False
        logger.info("Completed the transfer of data from the {0} temporary SQLite3 databases to the kdb file '{1}'".format(len(tempdbs), arguments.kdb))
        logger.info("Done")
    finally:
        for db in tempdbs:
            db.conn.close()
            db._engine.dispose()
            if not arguments.keep_sqlite:
                os.unlink(db.filepath)
            else:
                logger.debug("    Database file retained:    {0}".format(db.filepath))
        kdb_out._write_block(kdb_out._buffer)
        kdb_out._handle.flush()
        kdb_out._handle.close()


    
# def gen_hist(arguments):
#     from kdb import fileutil


#     hist = {}

#     with fileutil.open(arguments.kdb, mode='r') as ifile:
#         i = 0
#         for line in ifile:
#             kmer_id, count = (int(x) for x in line.rstrip().split("\t"))
#             if "\t" in line:
#                 try:
#                     hist[count] += 1
#                 except KeyError as e:
#                     hist[count] = 1
#             else:
#                 print(line)
#                 print(i)
#             i +=1

#     for k, v in hist.items():
#         print(k, v)
        
def get_root_logger(level):
    levels=[logging.WARNING, logging.INFO, logging.DEBUG]
    if level < 0 or level > 2:
        raise TypeError("{0}.get_root_logger expects a verbosity between 0-2".format(__file__))
    logging.basicConfig(level=levels[level], format="%(levelname)s: %(asctime)s %(funcName)s L%(lineno)s| %(message)s", datefmt="%Y/%m%d %I:%M:%S")
    root_logger = logging.getLogger()
    return root_logger


if __name__ == '__main__':
    sys.path.append("..")
    sys.path.remove(os.path.dirname(os.path.abspath(__file__)))
    
    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(help="Use --help with sub-commands")


    profile_parser = subparsers.add_parser("profile", help="Parse data into the database from one or more sequence files")
    profile_parser.add_argument("-v", "--verbose", help="Prints warnings to the console by default", default=0, action="count")
    profile_parser.add_argument("-p", "--parallel", type=int, default=1, choices=list(range(1, cpu_count()+1)), help=argparse.SUPPRESS)
    profile_parser.add_argument("-b", "--fastq-block-size", type=int, default=100000, help=argparse.SUPPRESS)
    #profile_parser.add_argument("--keep-S3-file", action="store_true", help="Download S3 file to the current working directory")
    profile_parser.add_argument("--keep-sqlite", action="store_true", help=argparse.SUPPRESS)
    profile_parser.add_argument("--not-strand-specific", action="store_false", default=True, help="Retain k-mers from the forward strand of the fast(a|q) file only")
    #profile_parser.add_argument("--no-metadata", dest="metadata", action="store_false", default=True, help="Include k-mer metadata in the .kdb")
    profile_parser.add_argument("-k", default=12, type=int, help="Choose k-mer size (Default: 12)")
    profile_parser.add_argument("seqfile", nargs="+", type=str, metavar="<.fasta|.fastq>", help="Fasta or fastq files")
    profile_parser.add_argument("kdb", type=str, help="Kdb file")
    profile_parser.set_defaults(func=profile)

    header_parser = subparsers.add_parser("header", help="Print the YAML header and exit")
    header_parser.add_argument("-v", "--verbose", help="Prints warnings to the console by default", default=0, action="count")
    header_parser.add_argument("-j", "--json", help="Print as JSON. DEFAULT: YAML")
    header_parser.add_argument("kdb", type=str, help="A k-mer database file (.kdb)")
    header_parser.set_defaults(func=header)
    
    view_parser = subparsers.add_parser("view", help="View the contents of the kdb file")
    view_parser.add_argument("-v", "--verbose", help="Prints warnings to the console by default", default=0, action="count")
    view_parser.add_argument("-H", "--header", action="store_true", help="Include header in the output")
    view_parser.add_argument("kdb", type=str, help="A k-mer database file (.kdb)")
    view_parser.set_defaults(func=view)
    
    dist_parser = subparsers.add_parser("distance", help="Calculate various distance metrics between profiles")
    dist_parser.add_argument("-v", "--verbose", help="Prints warnings to the console by default", default=0, action="count")
    dist_parser.add_argument("metric", choices=["correlation"], default=None, help="Choice of distance metric between two profiles")
    dist_parser.add_argument("kdb", nargs="+", type=str, metavar="<kdbfile1 kdbfile2 ...>", help="Two or more KDB files")
    dist_parser.set_defaults(func=distances)


    index_parser = subparsers.add_parser("index", help="Create a index file that can be held in memory")
    index_parser.add_argument("-v", "--verbose", help="Prints warnings to the console by default", default=0, action="count")
    index_parser.add_argument("kdb", type=str, help="A k-mer database file (.kdb)")
    index_parser.add_argument("kdbi", type=str, help="Output index file (.kdbi)")
    index_parser.set_defaults(func=index_file)

    
    args=parser.parse_args()
    if len(sys.argv) == 1:
        sys.exit(-1)
    else:
        logger=get_root_logger(args.verbose)
        #logger.debug(sys.path)
        args.func(args)
